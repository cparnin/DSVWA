## Semgrep Findings

- **Found 'subprocess' function 'check_output' with 'shell=True'. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.** in `dsvw.py:39`
  - ðŸ’¡ ***Fix details for finding 1**: Change the call to `subprocess.check_output` by setting `shell=False`. This can be done by passing the command and its arguments as a list rather than a single string. For example, if the original line is: ```python output = subprocess.check_output("some_command --option value", shell=True) ``` It should be modified to: ```python output = subprocess.check_output(["some_command", "--option", "value"], shell=False) ``` *
- **The application might dynamically evaluate untrusted input, which can lead to a code injection vulnerability. An attacker can execute arbitrary code, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing code containing user input. If this is unavoidable, validate and sanitize the input, and use safe alternatives for evaluating user input.** in `dsvw.py:57`
  - ðŸ’¡ ***Fix details for finding 2**: To mitigate the risk of a code injection vulnerability, avoid executing any code that directly incorporates untrusted user input. If evaluation of user input is unavoidable, implement strict validation and sanitation. This can include using whitelists for allowed input formats and types or employing libraries like `jsonschema` for JSON inputs. For example: ```python if is_valid(input_data):  # Implement a validation function result = eval(safe_expression)  # Use a safe method instead of eval() else: raise ValueError("Invalid input") ``` Always prefer safer alternatives for handling user input, such as using parameterized queries for databases or specific parsing methods for structured input. *
- **Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape by default. This is dangerous if you are rendering to a browser because this allows for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()' to only enable automatic escaping for certain file extensions.** in `scanner/report.py:5`
  - ðŸ’¡ ***Fix details for finding 3**: Update the Jinja2 environment configuration to enable autoescaping. This can be accomplished by adding the `autoescape=True` parameter when creating the Jinja2 environment. For example: ```python from jinja2 import Environment, FileSystemLoader env = Environment(loader=FileSystemLoader('templates'), autoescape=True) ``` Alternatively, utilize `select_autoescape()` to enable escaping based on file extensions: ```python from jinja2 import Environment, FileSystemLoader, select_autoescape env = Environment( loader=FileSystemLoader('templates'), autoescape=select_autoescape(['html', 'xml']) ) ``` This ensures that any content rendered in web contexts is automatically escaped, mitigating the risk of XSS attacks.*
