## Semgrep Findings

- **Found 'subprocess' function 'check_output' with 'shell=True'. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.** in `dsvw.py:39`
  - ðŸ’¡ ***Fix details for finding 1**: Change the call to `subprocess.check_output()` to disable shell execution. This can be done by ensuring all command and arguments are passed as a list and setting `shell=False`. For example, if the original line is: ```python output = subprocess.check_output("ls -l", shell=True) ``` Change it to: ```python output = subprocess.check_output(["ls", "-l"], shell=False) ``` *
- **The application might dynamically evaluate untrusted input, which can lead to a code injection vulnerability. An attacker can execute arbitrary code, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing code containing user input. If this is unavoidable, validate and sanitize the input, and use safe alternatives for evaluating user input.** in `dsvw.py:57`
  - ðŸ’¡ ***Fix details for finding 2**: Avoid executing code with untrusted input. If dynamically executing code is necessary, implement strict validation and sanitization of the input. Use regex or a whitelist of acceptable values to validate user input before any evaluation. An example validation could look like: ```python import re  user_input = "some user input" if re.match("^[a-zA-Z0-9_]+$", user_input):  # Allow only alphanumeric and underscore # safely evaluate or use the input else: raise ValueError("Invalid input") ``` Additionally, consider using safe alternatives like `literal_eval` from the `ast` module for evaluating simple data structures. *
- **Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape by default. This is dangerous if you are rendering to a browser because this allows for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()' to only enable automatic escaping for certain file extensions.** in `scanner/report.py:5`
  - ðŸ’¡ ***Fix details for finding 3**: Enable autoescaping in the Jinja2 environment to protect against XSS vulnerabilities. Modify the environment setup to include `autoescape=True` or utilize `jinja2.select_autoescape()` for specifying which file extensions should have autoescaping enabled. For example: ```python from jinja2 import Environment, select_autoescape  env = Environment( autoescape=select_autoescape(['html', 'xml']), loader=FileSystemLoader('templates') ) ``` This ensures that templates rendered with HTML or XML types are automatically escaped, enhancing security against XSS attacks.*

## Gitleaks Findings

- **No message** in `unknown file:?`
  - ðŸ’¡ ***Conduct a Thorough Security Audit**: Review the system for unrecognized or unknown files. Utilize tools to scan for malware and check the integrity of all files by comparing them against known good versions. *
